对象注入游戏，先注入的，先画（底部）


重写DrawCOMP 让它也具有多态+函数指针

在第二状态的时候，好像不能退出？


 //生成的材质是只有宽高的，只有在copy函数中，才指定把材质放到什么区域



//Stand_Physics应该加一个是否可以飘到窗外的变量


计划在PINPONG完成再研究一下DRAWCOMP函数，让DRAWCOMP写起来更顺手


2.3
计划加入按钮对象生成

重写了DRAW_COMP让它可以加载函数指针，使渲染更加灵活
但是保留了原本简单的COMP 中的DRAW,把DRAWCOMP的代码给了SPRITECOMP

标准按钮绘画函数只完成了色块渲染，没有对注入的素材做处理



2.2
为game类加入了可以一下注入大量对象指针的函数SetActors
//好像没啥用

为对象失效提供了解决方案

在这种情况下，你可以使用动态内存分配来解决内存失效的问题。
可以使用 `new` 操作符在堆上分配内存，并返回指向该内存的指针。
这样，当函数完成后，内存不会注销，因此你可以在其他地方继续使用它。

对于你的情况，你可以将返回类型改为 `actor*`，而不是 `actor`，并使用 `new` 为其分配内存。、
然后将返回的指针存储在 `vector<actor*>` 中。下面是一个示例代码：

```cpp
actor* GenerateCustomActor()
{
    actor* customActor = new actor(); // 使用 new 在堆上分配内存
    // 在这里进行自定义 actor 的初始化
    return customActor;
}

void ActorVectorInit(Game* gameptr)
{
    vector<actor*> actors;
    actors.push_back(GenerateCustomActor());
    // 将生成的 actor 指针存储在 vector 中
    gameptr->setActors(actors); // 假设 Game 类提供了设置 actors 的方法
}
```

**注意**：使用动态内存分配后，不要忘记在适当的时候释放内存，以免发生内存泄漏。
在你不再使用这些动态分配的内存时，可以使用 `delete` 操作符释放内存。

更新了game的析构函数，让内存管理更方便


有感:一个游戏只会出现一个game,所以做game的管道类，不如提早声明game。方便下面用指针引用它
多界面切换，取决于game中的枚举类型gametype的状态（可以在循环的时候比较来装载对象）
而状态的改变，可以放到对象历遍中进行（然后使用game的指针来改变game的状态）

加入了强枚举类型gamestate

为Game类增加了gamestate相应的变量

完成了页面切换效果
//要切换状态，记得把ISRUNING停一下

/*2/1
*
*物理模拟遇到的BUG：判断符号是时候，如果一个是0.自动判断符号相等
*
*加入管道类（phyjson集总和查找）
*这让json中的name就很重要了
*
*
*//为什么监听空格发出板上的球不借助管道类是复杂的
*因为这涉及了三个对象，我们的watcher,trigger都是对两个对象负责的，这注定会复杂
*所以，我打算在watcher中实现这个功能
*
*关于PIPE::FIND的使用：传入字符串常量是没有问题的，因为C++中string的一个构造函数就是
*接受字符串构造出string
*
*好想法：可以用GETTICKS来获得高质量的随机数
*
*发球方法BUG：按了空格，球转了，可是却不动,原来是过早的改变了球的TYPE标记
*导致IF判断语句无效
*
*写一个计分器对象
*关于TYPE的使用：一定是向里面添加多的变量就是区分对象的方法吗？
*不是的，我们可以使用管道搜索嘛
*
*写一个字体渲染类
*
*感觉管道类可以多创建几个（comp的,actor的）
*
*可以把那个联合体里塞几个结构体，一个结构体对应一个对象
*这样就可以传输更多的信息了
*
*研究一下：可不可以在创建目标类型的时候自动把他们加入管道
*COMPPIPE的这个可以实现
*
*为什么我们需要管道？因为函数指针需要通信！
*





/*1/31
*修好了3个BUG
*其中球速度异常和板不正常反应这两个BUG都是由于：
*trigger类中把目标类弄混了（球的四点被赋值成了板的四点）
*
*板不动，其一是基于事件的scancode的编写
*（太蠢了，基于事件的按键查询本来就很蠢，后来使用state方法完成了）
*(现在非常丝滑)
*其二是没有装载PHY模块
*
*目前在编写球的多状态：
*要重新写球的物理函数（基于flag检测的）
*还有球对板的触发函数（板是装载这个函数的）（约定这么说了）
*
*Ball_Phy(420)://!记得再发球的时候，把这些状态改回来
*
*还剩下发球的程序没写
*
*+板打球的时候，自己的速度（大小方向）也会影响球的速度
*/


/*1/30
*actor中的COMP查找可以一下返回所有某类型的COMP
*
*有感
*//所有的对象操作，都应该在类中封装，而不该在GAME的循环中出现
*//这既符合封装的规范，也让修改和移植方便
*
*有感
*加入触发器之后，对象注入顺序也不是很必要了
*
*/


/*
* 1/29
******************************************
*将代码重构一遍，更符合需求，让编写更简单
*
*明确了两个问题：2
*多态组件化编程有两个通信难题：层通信和对象通信
*******************************************
*PhyJSON改为ACTOR对象的私有属性，不在COMP中做属性，精简结构
*将PHYJSON*作为COMP属性，让同步和修改更加简单和直接
*如此一来，“层通信“的问题就解决了（层指的是输入处理输出这三个大层 ）3
**********************************************
*把ActorID作为string name写入PHYJSON中
*
*********************************************
*COMPTYPE：Watcher
*删除了复杂的按键监听，现在是事件监听器
*
*事实证明，这是可行的，借助函数指针的威力
*********************************************
*增加了一种新的COMP类型：触发器
*这让对象间的通信很方便
********************************************
*在PHYJSON中加了UNION：：TYPE
*(毕竟一个周怎每次只描述一个对像)
*支持一个对象的多种状态
*这让对象之间的状态访问可以实现
*而且还省内存
*
*有了这个直接删除MESSAGE和FLAG
**********************************************
*使用函数指针技术，重写了Trigger和Physics类
*让这两个类的形态更加稳定
*（这也让自定义数据必须强制刷新，很好 ）
**********************************************
*/



做一个头文件

/*
*1/28
* 将所有代码重构一次，让目标更明确,结构更简单
*
* 删除了枚举类型POST ,ORDER，ACRORID，WATCHER（直接使用SDL_scancode）
* 删去了CompType中的NULLER值
*
* 保留了message枚举，考虑它的用途
* 把所有的枚举类型命名改为全大写
*
* actor中加入了返回指定comptype指针的函数（最重要更新）
*
* 给COMP类加入了Watch函数，让COMP更好的对应游戏进行的三个主函数（重要更新）
* 感觉sprite函数的update函数不是很重要啊，毕竟总要和PHY组件通信，保持一致
* 为了以后实现粒子效果方便保留精灵绘画函数额外创造DrawComp类
*
* 更好的封装了comp类的COMPTYPE参数，（变为私有属性，GetCompType才可以访问）
* 让编写程序时 对COMPTYPE的对比不会笔误，写成改变COMPTYPE
*
* 更改了comp的默认构造函数，让构建新的组件类时不会忘记确定compare type参数
*
* 让comp类中的update函数变为虚函数（而不是纯虚函数），因为发现不是所有的构建都要用到它
*
* 删去了COMP类中的virtual void Call_LoadingPhy(PhyJson input)函数
* 删去了COMP类中的virtual void Call_LoadingFlag(Flag input)函数
* 毕竟Compound类中的 PHY Johnson 本来可以直接访问 ，和一系列无用的相关代码
*
* 删去了bool PointInRect(SDL_Point pt, SDL_Rect rect)，使用SDL自带的函数
* 


/*
* 日记：
* 1/27
*加入了ID枚举和管理
*重写了大部分函数
* 借助C++虚函数重写特性对COMP类重写，
* ACTOR加入了comp向量组，可以更方便更安全的操作组件
*意识到了多态虚函数重写的顺序的重要作用，解决了内存堆栈读取冲突问题
*
* 意识到了画面，物理不同步的情况
*
* 有必要把compound type给封装起来 ,否则对比的时候如果少写一个等于号那就是改变了属性了
*
* 有必要在game中存储精灵，毕竟做粒子特效不能专门给每个粒子注册一个对象吧











